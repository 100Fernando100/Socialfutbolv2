{
  "name": "Ops-1 Component 2 - Execution Engine (FIXED)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "ops1/execute",
        "responseMode": "responseNode",
        "options": {
          "rawBody": true
        }
      },
      "id": "webhook-execute",
      "name": "Webhook - Execute Task",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [0, 400],
      "webhookId": "ops1-execute"
    },
    {
      "parameters": {
        "jsCode": "// Validate input and extract task details\nconst input = $input.first().json;\n\n// Required fields validation\nconst requiredFields = ['client_id', 'task_description', 'mode'];\nfor (const field of requiredFields) {\n  if (!input[field]) {\n    throw new Error(`VALIDATION_ERROR: ${field} is required`);\n  }\n}\n\n// Validate mode\nif (!['excel', 'sql'].includes(input.mode)) {\n  throw new Error('VALIDATION_ERROR: mode must be \"excel\" or \"sql\"');\n}\n\n// Validate client_id format\nconst clientIdPattern = /^[A-Za-z0-9_-]+$/;\nif (!clientIdPattern.test(input.client_id)) {\n  throw new Error('VALIDATION_ERROR: client_id contains invalid characters');\n}\n\n// Generate task ID\nconst taskId = `TASK_${input.client_id}_${Date.now()}`;\n\nreturn {\n  json: {\n    client_id: input.client_id,\n    task_id: taskId,\n    task_description: input.task_description,\n    mode: input.mode,\n    data: input.data || null,\n    schema_whitelist: input.schema_whitelist || null,\n    namespace: `${input.client_id}_RULES`,\n    start_time: Date.now()\n  }\n};"
      },
      "id": "validate-input",
      "name": "Validate Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [220, 400]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT client_id, license_status FROM clients WHERE client_id = '{{ $json.client_id }}' AND license_status = 'active';",
        "options": {}
      },
      "id": "check-license",
      "name": "Check Client License",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [440, 400],
      "credentials": {
        "postgres": {
          "id": "POSTGRES_CREDENTIAL_ID",
          "name": "Ops1 PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "license-valid",
              "leftValue": "={{ $json.length }}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "license-valid",
      "name": "License Valid?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [660, 400]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"success\": false,\n  \"error\": \"LICENSE_ERROR\",\n  \"message\": \"Client license is not active or client does not exist\",\n  \"client_id\": \"{{ $('Validate Input').item.json.client_id }}\"\n}",
        "options": {
          "responseCode": 403
        }
      },
      "id": "respond-license-error",
      "name": "Respond - License Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [880, 280]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO access_log (client_id, task_id, action_type, namespace_accessed, status, metadata)\nVALUES (\n  '{{ $('Validate Input').item.json.client_id }}',\n  '{{ $('Validate Input').item.json.task_id }}',\n  'execution_start',\n  '{{ $('Validate Input').item.json.namespace }}',\n  'success',\n  '{\"mode\": \"{{ $('Validate Input').item.json.mode }}\"}'::jsonb\n)\nRETURNING log_id;",
        "options": {}
      },
      "id": "log-execution-start",
      "name": "Log Execution Start",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [880, 520],
      "credentials": {
        "postgres": {
          "id": "POSTGRES_CREDENTIAL_ID",
          "name": "Ops1 PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/embeddings",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"text-embedding-3-small\",\n  \"input\": \"{{ $('Validate Input').item.json.task_description }}\"\n}",
        "options": {
          "timeout": 30000
        }
      },
      "id": "embed-task",
      "name": "Embed Task Description",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1100, 520],
      "credentials": {
        "httpHeaderAuth": {
          "id": "OPENAI_CREDENTIAL_ID",
          "name": "OpenAI API Key"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "embedding-check",
              "leftValue": "={{ $json.data && $json.data[0] && $json.data[0].embedding && $json.data[0].embedding.length > 100 }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-embedding",
      "name": "Embedding OK?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1320, 520],
      "notes": "NUEVO: Verifica que el embedding se generó correctamente"
    },
    {
      "parameters": {
        "jsCode": "// NUEVO: Fallback cuando embedding falla (rate limit, timeout, etc.)\nconst taskData = $('Validate Input').first().json;\n\nconsole.error('[Ops-1] Embedding falló - usando fallback sin reglas específicas');\n\nreturn {\n  json: {\n    ...taskData,\n    client_rules: [],\n    rules_context: 'No se pudo generar embedding de la consulta (posible rate limit o error de API). Procediendo sin reglas específicas del cliente.',\n    rules_count: 0,\n    embedding_failed: true,\n    threshold_used: 0.75\n  }\n};"
      },
      "id": "embedding-fallback",
      "name": "Embedding Fallback",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1540, 700],
      "notes": "NUEVO: Fallback cuando OpenAI falla"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://{{ $env.PINECONE_HOST }}/query",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Api-Key",
              "value": "={{ $env.PINECONE_API_KEY }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"namespace\": \"{{ $('Validate Input').item.json.namespace }}\",\n  \"vector\": {{ JSON.stringify($json.data[0].embedding) }},\n  \"topK\": 10,\n  \"includeMetadata\": true\n}",
        "options": {
          "timeout": 30000
        }
      },
      "id": "query-pinecone",
      "name": "Retrieve Client Rules",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1540, 520],
      "credentials": {
        "httpHeaderAuth": {
          "id": "PINECONE_CREDENTIAL_ID",
          "name": "Pinecone API Key"
        }
      },
      "notes": "FIXED: Agregado header Api-Key y timeout 30s"
    },
    {
      "parameters": {
        "jsCode": "// === PARSE RETRIEVED RULES - FIXED VERSION ===\n// Cambios: Umbral 0.75, fallback robusto, logging para auditoría\n\nconst pineconeResponse = $input.first().json;\nconst taskData = $('Validate Input').first().json;\n\n// CONFIGURACIÓN - Ajusta según testing\nconst THRESHOLD = 0.75;  // FIXED: Subido de 0.5 para legal/auditoría\n\n// 1. Protección contra respuesta inválida de Pinecone\nif (!pineconeResponse || !Array.isArray(pineconeResponse.matches)) {\n  console.warn('[Ops-1] Pinecone response inválida o sin matches');\n  return {\n    json: {\n      ...taskData,\n      client_rules: [],\n      rules_context: 'Error en recuperación de reglas. Usando mejores prácticas estándar.',\n      rules_count: 0,\n      retrieval_error: true,\n      threshold_used: THRESHOLD\n    }\n  };\n}\n\n// 2. Filtrar con umbral alto + valores por defecto en metadata\nconst clientRules = pineconeResponse.matches\n  .filter(match => (match.score || 0) > THRESHOLD)\n  .map(match => ({\n    rule_id: match.metadata?.rule_id || 'unknown',\n    category: match.metadata?.category || 'uncategorized',\n    rule_text: match.metadata?.rule_text || '[texto no disponible]',\n    confidence: match.metadata?.confidence || 'UNKNOWN',\n    relevance_score: match.score\n  }));\n\n// 3. Construir contexto con fallback\nlet rulesContext;\nif (clientRules.length > 0) {\n  rulesContext = clientRules\n    .map(r => `[${r.rule_id}] (${r.category}): ${r.rule_text} (score: ${r.relevance_score.toFixed(3)})`)\n    .join('\\n\\n');\n} else {\n  rulesContext = `No se encontraron reglas con relevancia > ${THRESHOLD}. ` +\n    'Usando mejores prácticas estándar. ' +\n    'Recomendación: revisar manualmente o ampliar descripción de tarea.';\n}\n\n// 4. Logging para auditoría\nconst totalMatches = pineconeResponse.matches.length;\nconst avgScore = totalMatches > 0 \n  ? (pineconeResponse.matches.reduce((sum, m) => sum + (m.score || 0), 0) / totalMatches).toFixed(3)\n  : 0;\n\nconsole.log(`[Ops-1] Retrieval: ${clientRules.length}/${totalMatches} reglas > ${THRESHOLD} (avg score: ${avgScore})`);\n\nreturn {\n  json: {\n    ...taskData,\n    client_rules: clientRules,\n    rules_context: rulesContext,\n    rules_count: clientRules.length,\n    threshold_used: THRESHOLD,\n    total_matches: totalMatches,\n    avg_score: parseFloat(avgScore)\n  }\n};"
      },
      "id": "parse-rules",
      "name": "Parse Retrieved Rules",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1760, 520],
      "notes": "FIXED: Umbral 0.75, fallback robusto, logging"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "mode-check",
              "leftValue": "={{ $json.mode }}",
              "rightValue": "excel",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "mode-branch",
      "name": "Excel or SQL Mode?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1980, 520]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.anthropic.com/v1/messages",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "anthropic-version",
              "value": "2023-06-01"
            },
            {
              "name": "content-type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"claude-3-5-haiku-latest\",\n  \"max_tokens\": 4096,\n  \"system\": \"You are the Ops-1 Excel Processing Module. You generate Python code using Pandas to perform data transformations on spreadsheet data.\\n\\nINPUTS PROVIDED:\\n1. Task Description: What the client wants done\\n2. Client Rule Set: Specific formatting and handling rules for this client\\n3. Data Schema: Column names and sample data\\n\\nYOUR FUNCTION:\\nGenerate Python code that accomplishes the task while respecting ALL client rules.\\n\\nSTRICT CONSTRAINTS:\\n1. Use only: pandas, numpy, openpyxl, csv (standard libraries)\\n2. Never use: os, subprocess, requests, or any network/filesystem operations\\n3. Never execute arbitrary code - only data transformations\\n4. Input variable is always: `df` (pandas DataFrame)\\n5. Output must be assigned to: `result_df` (pandas DataFrame)\\n\\nCODE STRUCTURE:\\n```python\\nimport pandas as pd\\nimport numpy as np\\n\\n# Input: df (provided)\\n\\n# [Your transformation code here]\\n\\nresult_df = [final transformed dataframe]\\n```\\n\\nDOCUMENTATION REQUIREMENT:\\nAdd a comment before each operation citing which Client Rule it follows:\\n```python\\n# Applying Rule R003: Format dates as DD/MM/YYYY\\ndf['date_column'] = pd.to_datetime(df['date_column']).dt.strftime('%d/%m/%Y')\\n```\\n\\nIf no specific rule applies to an operation, note:\\n```python\\n# Standard operation: No specific client rule applies\\n```\\n\\nERROR HANDLING:\\n- If the task is impossible with the given data, return code that raises a descriptive ValueError\\n- Never silently fail or return partial results\",\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"TASK DESCRIPTION:\\n{{ $json.task_description }}\\n\\nCLIENT RULES:\\n{{ $json.rules_context }}\\n\\nDATA SCHEMA:\\n{{ JSON.stringify($json.data) }}\"\n    }\n  ]\n}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "excel-execution",
      "name": "Excel Execution (Claude)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2200, 400],
      "credentials": {
        "httpHeaderAuth": {
          "id": "ANTHROPIC_CREDENTIAL_ID",
          "name": "Anthropic API Key"
        }
      },
      "notes": "FIXED: Agregado timeout 60s"
    },
    {
      "parameters": {
        "jsCode": "// Parse Excel execution result\nconst response = $input.first().json;\nconst taskData = $('Parse Retrieved Rules').first().json;\n\nif (!response.content || !response.content[0] || !response.content[0].text) {\n  throw new Error('AI_ERROR: Invalid response from Excel execution');\n}\n\nlet generatedCode = response.content[0].text;\n\n// Extract code from markdown if wrapped\nconst codeMatch = generatedCode.match(/```(?:python)?\\s*([\\s\\S]*?)```/);\nif (codeMatch) {\n  generatedCode = codeMatch[1].trim();\n}\n\nreturn {\n  json: {\n    ...taskData,\n    execution: {\n      type: 'excel',\n      generated_output: generatedCode,\n      model_used: 'claude-3-5-haiku-latest',\n      execution_duration_ms: Date.now() - taskData.start_time\n    }\n  }\n};"
      },
      "id": "parse-excel",
      "name": "Parse Excel Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2420, 400]
    },
    {
      "parameters": {
        "jsCode": "// SQL Pre-Filter Security Check\nconst taskData = $input.first().json;\nconst taskDescription = taskData.task_description.toUpperCase();\n\n// Blocked keywords - these should NEVER pass\nconst blockedKeywords = [\n  'DROP', 'DELETE', 'TRUNCATE', 'ALTER', 'CREATE', 'INSERT', 'UPDATE',\n  'GRANT', 'REVOKE', 'EXEC', 'EXECUTE', 'XP_', 'SP_',\n  'SHUTDOWN', 'KILL', 'BACKUP', 'RESTORE'\n];\n\nfor (const keyword of blockedKeywords) {\n  if (taskDescription.includes(keyword)) {\n    throw new Error(`SECURITY_BLOCK: Prohibited SQL keyword detected: ${keyword}`);\n  }\n}\n\n// If schema whitelist exists, ensure it's valid\nif (taskData.schema_whitelist && !Array.isArray(taskData.schema_whitelist)) {\n  throw new Error('VALIDATION_ERROR: schema_whitelist must be an array');\n}\n\nreturn {\n  json: {\n    ...taskData,\n    security_precheck: 'passed'\n  }\n};"
      },
      "id": "sql-prefilter",
      "name": "SQL Pre-Filter (Security)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2200, 640]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.anthropic.com/v1/messages",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "anthropic-version",
              "value": "2023-06-01"
            },
            {
              "name": "content-type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"claude-3-5-haiku-latest\",\n  \"max_tokens\": 4096,\n  \"system\": \"You are the Ops-1 SQL Generation Module. You generate READ-ONLY SQL queries based on natural language requests.\\n\\nINPUTS PROVIDED:\\n1. Task Description: Natural language description of what data is needed\\n2. Client Rules: Specific requirements for this client\\n3. Schema Whitelist: Tables/columns the client is authorized to access\\n\\nSTRICT CONSTRAINTS:\\n1. ONLY generate SELECT statements\\n2. NEVER generate: INSERT, UPDATE, DELETE, DROP, ALTER, CREATE, TRUNCATE, GRANT, REVOKE\\n3. NEVER use: EXEC, EXECUTE, xp_, sp_ (stored procedures)\\n4. ONLY access tables in the provided whitelist\\n5. Always include WHERE clauses to limit data exposure\\n6. Always use LIMIT to prevent excessive data retrieval\\n\\nOUTPUT FORMAT:\\n```sql\\n-- Query Description: [Brief description]\\n-- Rules Applied: [List rule IDs used]\\nSELECT ...\\n```\\n\\nSECURITY NOTES:\\n- If the task requires write operations, respond with an error message explaining this is read-only\\n- If tables outside the whitelist are requested, list what was requested and what is available\",\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"TASK DESCRIPTION:\\n{{ $json.task_description }}\\n\\nCLIENT RULES:\\n{{ $json.rules_context }}\\n\\nSCHEMA WHITELIST (authorized tables/columns):\\n{{ JSON.stringify($json.schema_whitelist) }}\"\n    }\n  ]\n}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "sql-execution",
      "name": "SQL Execution (Claude)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2420, 640],
      "credentials": {
        "httpHeaderAuth": {
          "id": "ANTHROPIC_CREDENTIAL_ID",
          "name": "Anthropic API Key"
        }
      },
      "notes": "FIXED: Agregado timeout 60s"
    },
    {
      "parameters": {
        "jsCode": "// Parse SQL execution result\nconst response = $input.first().json;\nconst taskData = $('SQL Pre-Filter (Security)').first().json;\n\nif (!response.content || !response.content[0] || !response.content[0].text) {\n  throw new Error('AI_ERROR: Invalid response from SQL execution');\n}\n\nlet generatedSQL = response.content[0].text;\n\n// Extract SQL from markdown if wrapped\nconst sqlMatch = generatedSQL.match(/```(?:sql)?\\s*([\\s\\S]*?)```/);\nif (sqlMatch) {\n  generatedSQL = sqlMatch[1].trim();\n}\n\nreturn {\n  json: {\n    ...taskData,\n    execution: {\n      type: 'sql',\n      generated_output: generatedSQL,\n      model_used: 'claude-3-5-haiku-latest',\n      execution_duration_ms: Date.now() - taskData.start_time\n    }\n  }\n};"
      },
      "id": "parse-sql",
      "name": "Parse SQL Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2640, 640]
    },
    {
      "parameters": {
        "mode": "passThrough",
        "output": "json"
      },
      "id": "merge-results",
      "name": "Merge Results",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [2860, 520]
    },
    {
      "parameters": {
        "jsCode": "// Prepare complete audit package for Compliance Module\nconst data = $input.first().json;\n\nconst auditPackage = {\n  task_id: data.task_id,\n  client_id: data.client_id,\n  task_description: data.task_description,\n  mode: data.mode,\n  \n  execution: {\n    generated_output: data.execution.generated_output,\n    model_used: data.execution.model_used,\n    execution_duration_ms: data.execution.execution_duration_ms\n  },\n  \n  compliance: {\n    rules_retrieved: data.rules_count,\n    client_rules: data.client_rules,\n    threshold_used: data.threshold_used || 0.75,\n    avg_score: data.avg_score || 0\n  },\n  \n  metadata: {\n    namespace: data.namespace,\n    timestamp: new Date().toISOString(),\n    schema_whitelist: data.schema_whitelist\n  }\n};\n\nreturn {\n  json: auditPackage\n};"
      },
      "id": "prepare-audit",
      "name": "Prepare Audit Package",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3080, 520]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.N8N_WEBHOOK_BASE_URL }}/webhook/ops1/compliance",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json) }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "send-to-compliance",
      "name": "Send to Compliance Module",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [3300, 520]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json) }}",
        "options": {}
      },
      "id": "respond-final",
      "name": "Respond - Final Result",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [3520, 520]
    }
  ],
  "connections": {
    "Webhook - Execute Task": {
      "main": [
        [
          {
            "node": "Validate Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Input": {
      "main": [
        [
          {
            "node": "Check Client License",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Client License": {
      "main": [
        [
          {
            "node": "License Valid?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "License Valid?": {
      "main": [
        [
          {
            "node": "Respond - License Error",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Log Execution Start",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log Execution Start": {
      "main": [
        [
          {
            "node": "Embed Task Description",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Embed Task Description": {
      "main": [
        [
          {
            "node": "Embedding OK?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Embedding OK?": {
      "main": [
        [
          {
            "node": "Retrieve Client Rules",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Embedding Fallback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Embedding Fallback": {
      "main": [
        [
          {
            "node": "Excel or SQL Mode?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Retrieve Client Rules": {
      "main": [
        [
          {
            "node": "Parse Retrieved Rules",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Retrieved Rules": {
      "main": [
        [
          {
            "node": "Excel or SQL Mode?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Excel or SQL Mode?": {
      "main": [
        [
          {
            "node": "Excel Execution (Claude)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "SQL Pre-Filter (Security)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Excel Execution (Claude)": {
      "main": [
        [
          {
            "node": "Parse Excel Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SQL Pre-Filter (Security)": {
      "main": [
        [
          {
            "node": "SQL Execution (Claude)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SQL Execution (Claude)": {
      "main": [
        [
          {
            "node": "Parse SQL Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Excel Result": {
      "main": [
        [
          {
            "node": "Merge Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse SQL Result": {
      "main": [
        [
          {
            "node": "Merge Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Results": {
      "main": [
        [
          {
            "node": "Prepare Audit Package",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Audit Package": {
      "main": [
        [
          {
            "node": "Send to Compliance Module",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send to Compliance Module": {
      "main": [
        [
          {
            "node": "Respond - Final Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "name": "Ops-1",
      "createdAt": "2025-01-21T00:00:00.000Z",
      "updatedAt": "2025-01-21T00:00:00.000Z"
    },
    {
      "name": "Execution",
      "createdAt": "2025-01-21T00:00:00.000Z",
      "updatedAt": "2025-01-21T00:00:00.000Z"
    },
    {
      "name": "FIXED",
      "createdAt": "2025-01-22T00:00:00.000Z",
      "updatedAt": "2025-01-22T00:00:00.000Z"
    }
  ],
  "triggerCount": 1,
  "updatedAt": "2025-01-22T00:00:00.000Z",
  "versionId": "2"
}

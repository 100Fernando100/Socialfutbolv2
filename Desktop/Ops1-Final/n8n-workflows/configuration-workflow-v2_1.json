{
  "name": "Ops-1 Component 1 - Configuration Module (v2.1 - Cross-Border Fiscal)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "ops1/configure",
        "responseMode": "responseNode",
        "options": {
          "rawBody": true
        }
      },
      "id": "webhook-trigger",
      "name": "Webhook - Configuration Request",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [0, 300],
      "webhookId": "ops1-configure"
    },
    {
      "parameters": {
        "jsCode": "// Validate Client ID and extract input data\nconst input = $input.first().json;\n\nif (!input.client_id) {\n  throw new Error('VALIDATION_ERROR: client_id is required');\n}\n\nif (!input.data || !input.data.content) {\n  throw new Error('VALIDATION_ERROR: data.content is required');\n}\n\n// Validate client_id format (alphanumeric, underscores, hyphens only)\nconst clientIdPattern = /^[A-Za-z0-9_-]+$/;\nif (!clientIdPattern.test(input.client_id)) {\n  throw new Error('VALIDATION_ERROR: client_id contains invalid characters');\n}\n\nreturn {\n  json: {\n    client_id: input.client_id,\n    raw_content: input.data.content,\n    configuration_date: new Date().toISOString(),\n    task_id: `CONFIG_${input.client_id}_${Date.now()}`,\n    namespace: `${input.client_id}_RULES`\n  }\n};"
      },
      "id": "validate-client",
      "name": "Validate Client ID",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [220, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO access_log (client_id, task_id, action_type, namespace_accessed, status, metadata)\nVALUES ('{{ $json.client_id }}', '{{ $json.task_id }}', 'configuration', '{{ $json.namespace }}', 'success', '{\"stage\": \"start\"}'::jsonb)\nRETURNING log_id;",
        "options": {}
      },
      "id": "log-start",
      "name": "Log Access Start",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [440, 300],
      "credentials": {
        "postgres": {
          "id": "POSTGRES_CREDENTIAL_ID",
          "name": "Ops1 PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// === PDF FISCAL CLEANER PRO v2.1 - Cross-Border NA/LATAM ===\n// Optimizado para: IRS Pubs, CRA guides, SAT/LISR, Tax Treaties\n\nlet text = $('Validate Client ID').first().json.raw_content || '';\n\n// Manejo edge cases: si es array (de multi-page PDFs)\nif (Array.isArray(text)) text = text.join('\\n');\n\n// 1. Eliminar numeración de páginas (variantes NA/LATAM)\ntext = text.replace(/\\b(Página|Pág\\.?|Page|Seite|Fol\\.?)\\s?[:\\-]?\\s?\\d+\\s?(de\\s?[:\\-]?\\s?\\d+)?\\b/gi, '');\ntext = text.replace(/\\b\\d+\\s?\\/\\s?\\d+\\b/g, '');\ntext = text.replace(/\\b-\\s?\\d+\\s?-\\b/g, '');\n\n// 2. Eliminar headers/pies repetitivos (IRS/CRA/SAT/Treaties)\nconst fiscalHeaders = [\n  /Canada Revenue Agency|Agence du revenu du Canada/gi,\n  /Internal Revenue Service|Department of the Treasury/gi,\n  /Servicio de Administración Tributaria|SAT/gi,\n  /Diario Oficial de la Federación|DOF/gi,\n  /Convention Between.*for the Avoidance of Double Taxation/gi,\n  /Tratado.*para Evitar la Doble Imposición/gi,\n  /Publication \\d{2,4}|Pub\\.? \\d{2,4}/gi,\n  /Form \\d{3,4}[A-Z]?(-[A-Z]+)?|Schedule [A-Z]/gi,\n  /T1 General|T2 Corporation|GST\\/HST/gi,\n  /©? ?\\d{4}.*?(rights reserved|derechos reservados)/gi,\n  /www\\.(irs\\.gov|canada\\.ca|sat\\.gob\\.mx)/gi,\n  /Cat\\.? No\\.? \\d+[A-Z]?/gi\n];\nfiscalHeaders.forEach(regex => text = text.replace(regex, ''));\n\n// 3. Unir oraciones/líneas rotas (crítico para artículos de tratados)\ntext = text.replace(/([^\\.\\!\\?\\n])\\n(?=[a-záéíóúñü])/g, '$1 ');\ntext = text.replace(/([a-záéíóúñü])\\n([A-ZÁÉÍÓÚÑÜ])/g, '$1 $2');\ntext = text.replace(/\\n{2,}/g, '\\n');\n\n// 4. Normalizar términos fiscales (ES/EN)\ntext = text.replace(/\\bArt\\.?\\s+/gi, 'Article ');\ntext = text.replace(/\\bArtículo\\s+/gi, 'Article ');\ntext = text.replace(/\\bSec\\.?\\s+(\\d)/gi, 'Section $1');\ntext = text.replace(/\\bSección\\s+/gi, 'Section ');\ntext = text.replace(/\\bPara\\.?\\s+/gi, 'Paragraph ');\ntext = text.replace(/\\bPárrafo\\s+/gi, 'Paragraph ');\n\n// 5. Limpieza final\ntext = text.replace(/\\s+/g, ' ');\ntext = text.replace(/[^\\w\\s\\.\\,\\;\\:\\(\\)\\[\\]\\%\\$\\-\\\\/°ªº¿\\¡\\!\\?&áéíóúñüÁÉÍÓÚÑÜ]/g, ' ');\ntext = text.trim();\n\nconst originalLength = $('Validate Client ID').first().json.raw_content?.length || 0;\nconst reductionPercent = originalLength > 0 \n  ? Math.round((1 - text.length / originalLength) * 100) \n  : 0;\n\nconsole.log(`[PDF Cleaner v2.1] Original: ${originalLength} → Cleaned: ${text.length} (${reductionPercent}% reduction)`);\n\nreturn {\n  json: {\n    ...$('Validate Client ID').first().json,\n    cleaned_content: text,\n    cleaning_applied: true,\n    original_length: originalLength,\n    cleaned_length: text.length,\n    reduction_percent: reductionPercent\n  }\n};"
      },
      "id": "pdf-cleaner",
      "name": "PDF Legal Cleaner Pro v2.1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [660, 300],
      "notes": "v2.1: Optimizado para Tax Treaties, IRS Pubs, CRA guides, SAT/LISR"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.anthropic.com/v1/messages",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "anthropic-version",
              "value": "2023-06-01"
            },
            {
              "name": "content-type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"claude-3-5-haiku-latest\",\n  \"max_tokens\": 4096,\n  \"system\": \"You are a Data Sanitization Module. Your function is to remove Personally Identifiable Information (PII) from text while preserving business logic and instructions.\\n\\nREMOVE AND REPLACE WITH PLACEHOLDERS:\\n- Full names → [NAME]\\n- Email addresses → [EMAIL]\\n- Phone numbers → [PHONE]\\n- Physical addresses → [ADDRESS]\\n- Social Insurance Numbers / SSN → [ID_NUMBER]\\n- Credit card numbers → [PAYMENT_INFO]\\n- Dates of birth → [DOB]\\n- IP addresses → [IP]\\n\\nPRESERVE:\\n- Business rules and instructions\\n- Tax rates, thresholds, and percentages\\n- Article/Section references from laws and treaties\\n- Formatting preferences\\n- Process descriptions\\n- Software/tool names\\n- Department names (without individual names)\\n\\nOUTPUT FORMAT:\\nReturn the sanitized text only. Do not add commentary or explanations.\\n\\nIf the input contains no PII, return it unchanged.\",\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"Sanitize the following text by removing all PII:\\n\\n{{ $json.cleaned_content }}\"\n    }\n  ]\n}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "pii-sanitization",
      "name": "PII Sanitization (Claude)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [880, 300],
      "credentials": {
        "httpHeaderAuth": {
          "id": "ANTHROPIC_CREDENTIAL_ID",
          "name": "Anthropic API Key"
        }
      },
      "notes": "Preserva referencias a artículos/secciones de tratados y leyes"
    },
    {
      "parameters": {
        "jsCode": "// Extract sanitized content from Claude response\nconst response = $input.first().json;\nconst previousData = $('PDF Legal Cleaner Pro v2.1').first().json;\n\nif (!response.content || !response.content[0] || !response.content[0].text) {\n  throw new Error('AI_ERROR: Invalid response from PII sanitization');\n}\n\nconst sanitizedContent = response.content[0].text;\n\nreturn {\n  json: {\n    ...previousData,\n    sanitized_content: sanitizedContent,\n    pii_sanitization_complete: true\n  }\n};"
      },
      "id": "parse-sanitized",
      "name": "Parse Sanitized Content",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1100, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.anthropic.com/v1/messages",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "anthropic-version",
              "value": "2023-06-01"
            },
            {
              "name": "content-type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"claude-3-5-sonnet-latest\",\n  \"max_tokens\": 8192,\n  \"system\": \"# CONFIGURATION EXTRACTION MODULE v2.1\\n## Fiscal & Tax Rules Extractor for Cross-Border Operations (CA-US-MX)\\n\\nYou are a specialized Configuration Extraction Module for fiscal and tax rules applicable to cross-border businesses operating between Canada, United States, and Mexico. Your primary users are Latino accounting professionals in the USA serving small business clients with cross-border activities.\\n\\n### EXTRACTION PRIORITIES (in order):\\n\\n1. WITHHOLDING TAXES (Retenciones)\\n   - Dividends: general rates vs. treaty-reduced rates (5% for ≥10% ownership, etc.)\\n   - Interest: bank loan exemptions, government securities (0%), arm's length conditions\\n   - Royalties: differences between software, patents, trademarks, know-how\\n   - Technical Services/Management Fees: Art. 7 (business profits) vs. separate services article\\n   - Wages: 183-day rule, PE implications\\n\\n2. INDIRECT TAXES (VAT/GST/HST)\\n   - Mexico IVA (16%): tasa 0% for exports\\n   - Canada GST/HST: place of supply rules, small supplier threshold ($30K CAD)\\n   - USA State Sales Tax: nexus triggers, marketplace facilitator rules\\n\\n3. COMMON DEDUCTIONS (US Small Business Focus)\\n   - Home Office: simplified ($5/sq ft, max $1,500) vs. actual (Form 8829)\\n   - Vehicle: standard mileage rate vs. actual expenses, substantiation rules\\n   - QBI Deduction (Sec. 199A): 20% deduction, phase-outs ($182,100/$364,200), SSTB exclusions\\n   - Section 179 + Bonus Depreciation: limits, SUV/truck exceptions\\n\\n4. TREATY PROVISIONS\\n   - US-Mexico (1992): Art. 10 (dividends), Art. 11 (interest), Art. 12 (royalties), Art. 7\\n   - US-Canada (1980): similar + Art. V (PE), Art. XXIX-A (LOB)\\n   - Canada-Mexico (2006): specific provisions for CA-MX flows\\n\\n5. SIMPLIFIED REGIMES\\n   - Canada: Small Supplier Exemption ($30K CAD threshold)\\n   - Mexico: RESICO (1-2.5% ISR on gross income, $3.5M MXN limit)\\n   - USA: State-level sales tax exemptions/thresholds\\n\\n### OUTPUT FORMAT (strict JSON):\\n\\n{\\n  \\\"extraction_metadata\\\": {\\n    \\\"client_id\\\": \\\"[FROM INPUT]\\\",\\n    \\\"configuration_version\\\": \\\"2.1\\\",\\n    \\\"source_language\\\": \\\"EN|ES|FR\\\",\\n    \\\"document_date\\\": \\\"[if identifiable]\\\"\\n  },\\n  \\\"rules\\\": [\\n    {\\n      \\\"rule_id\\\": \\\"R001\\\",\\n      \\\"category\\\": \\\"WITHHOLDING|VAT_GST_HST|DEDUCTIONS|TREATY|SIMPLIFIED_REGIME\\\",\\n      \\\"subcategory\\\": \\\"[specific type: dividends, home_office, etc.]\\\",\\n      \\\"applicable_countries\\\": [\\\"US\\\", \\\"CA\\\", \\\"MX\\\"],\\n      \\\"cross_border_flow\\\": {\\n        \\\"source_country\\\": \\\"US|CA|MX|null\\\",\\n        \\\"recipient_country\\\": \\\"US|CA|MX|null\\\"\\n      },\\n      \\\"rule_statement\\\": \\\"Clear, actionable rule\\\",\\n      \\\"parameters\\\": {\\n        \\\"rate\\\": \\\"[percentage or null]\\\",\\n        \\\"threshold\\\": \\\"[amount with currency or null]\\\"\\n      },\\n      \\\"conditions\\\": [\\\"List of conditions\\\"],\\n      \\\"exceptions\\\": [\\\"List of exceptions\\\"],\\n      \\\"source_citation\\\": {\\n        \\\"document_name\\\": \\\"Treaty/Law name\\\",\\n        \\\"article_section\\\": \\\"Art. X, Sec. Y\\\",\\n        \\\"direct_quote\\\": \\\"Verbatim text (max 200 chars)\\\"\\n      },\\n      \\\"confidence\\\": \\\"HIGH|MEDIUM|LOW\\\",\\n      \\\"practical_example\\\": \\\"Brief example for small Latino business in USA (max 100 chars)\\\"\\n    }\\n  ],\\n  \\\"ambiguities\\\": [\\n    {\\n      \\\"ambiguity_id\\\": \\\"A001\\\",\\n      \\\"category\\\": \\\"[category]\\\",\\n      \\\"issue_type\\\": \\\"MISSING_RULE|CONTRADICTION|VAGUE_LANGUAGE\\\",\\n      \\\"description\\\": \\\"Description of ambiguity\\\",\\n      \\\"client_clarification_needed\\\": \\\"Question to ask client\\\"\\n    }\\n  ],\\n  \\\"coverage_summary\\\": {\\n    \\\"withholding_taxes\\\": {\\\"extracted\\\": true, \\\"rule_count\\\": 0},\\n    \\\"vat_gst_hst\\\": {\\\"extracted\\\": false, \\\"reason\\\": \\\"...\\\"},\\n    \\\"deductions\\\": {\\\"extracted\\\": true, \\\"rule_count\\\": 0},\\n    \\\"treaty_provisions\\\": {\\\"extracted\\\": true, \\\"rule_count\\\": 0},\\n    \\\"simplified_regimes\\\": {\\\"extracted\\\": false, \\\"reason\\\": \\\"...\\\"}\\n  }\\n}\\n\\n### STRICT RULES:\\n- Extract ONLY explicit rules present in text — do NOT infer\\n- Always cite sources: no rule without source_citation\\n- Preserve original terminology in quotes (\\\"establecimiento permanente\\\", \\\"beneficial owner\\\")\\n- Flag effective dates when stated\\n- practical_example can be in Spanish for Latino audience\\n- Confidence: HIGH only if direct quote + clear citation; LOW if vague\\n- If no explicit rule found for a topic, include in ambiguities\",\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"Extract fiscal and tax configuration rules from the following sanitized documentation for client_id: {{ $json.client_id }}\\n\\nDocument content:\\n{{ $json.sanitized_content }}\"\n    }\n  ]\n}",
        "options": {
          "timeout": 120000
        }
      },
      "id": "rule-extraction",
      "name": "Rule Extraction (Claude) v2.1",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1320, 300],
      "credentials": {
        "httpHeaderAuth": {
          "id": "ANTHROPIC_CREDENTIAL_ID",
          "name": "Anthropic API Key"
        }
      },
      "notes": "v2.1: Prompt optimizado para cross-border CA-US-MX, schema expandido, Sonnet para mejor extracción"
    },
    {
      "parameters": {
        "jsCode": "// === PARSE & PREPARE RULES v2.1 ===\n// Maneja schema v2.1 con cross_border_flow, subcategory, practical_example\n\nconst response = $input.first().json;\nconst previousData = $('Parse Sanitized Content').first().json;\n\nif (!response.content || !response.content[0] || !response.content[0].text) {\n  throw new Error('AI_ERROR: Invalid response from rule extraction');\n}\n\nlet extractedRules;\ntry {\n  // Extract JSON from response (may be wrapped in markdown code blocks)\n  let jsonText = response.content[0].text;\n  const jsonMatch = jsonText.match(/```(?:json)?\\s*([\\s\\S]*?)```/);\n  if (jsonMatch) {\n    jsonText = jsonMatch[1];\n  }\n  extractedRules = JSON.parse(jsonText);\n} catch (e) {\n  throw new Error(`AI_ERROR: Failed to parse rule extraction JSON: ${e.message}`);\n}\n\n// Calculate retention expiry (default 12 months)\nconst retentionExpiry = new Date();\nretentionExpiry.setFullYear(retentionExpiry.getFullYear() + 1);\n\n// Prepare records for Pinecone with v2.1 schema\nconst pineconeRecords = extractedRules.rules.map((rule, index) => {\n  // Build embedding text: category + subcategory + rule + conditions\n  const embeddingText = [\n    rule.category,\n    rule.subcategory || '',\n    rule.rule_statement,\n    (rule.conditions || []).join('; ')\n  ].filter(Boolean).join(' | ');\n\n  return {\n    id: `${previousData.client_id}_${rule.rule_id}`,\n    values: [], // Will be populated by embedding\n    metadata: {\n      client_id: previousData.client_id,\n      rule_id: rule.rule_id,\n      category: rule.category,\n      subcategory: rule.subcategory || null,\n      rule_text: rule.rule_statement,\n      // Cross-border flow\n      source_country: rule.cross_border_flow?.source_country || null,\n      recipient_country: rule.cross_border_flow?.recipient_country || null,\n      applicable_countries: (rule.applicable_countries || []).join(','),\n      // Parameters\n      rate: rule.parameters?.rate || null,\n      threshold: rule.parameters?.threshold || null,\n      // Conditions & exceptions\n      conditions: JSON.stringify(rule.conditions || []),\n      exceptions: JSON.stringify(rule.exceptions || []),\n      // Citation\n      source_document: rule.source_citation?.document_name || null,\n      article_section: rule.source_citation?.article_section || null,\n      direct_quote: rule.source_citation?.direct_quote || null,\n      // Confidence & example\n      confidence: rule.confidence,\n      practical_example: rule.practical_example || null,\n      // Metadata\n      configuration_date: previousData.configuration_date,\n      retention_expiry: retentionExpiry.toISOString(),\n      version: extractedRules.extraction_metadata?.configuration_version || '2.1',\n      embedding_text: embeddingText\n    }\n  };\n});\n\n// Check if requires human review\nconst hasLowConfidence = extractedRules.rules.some(r => r.confidence === 'LOW');\nconst hasAmbiguities = (extractedRules.ambiguities?.length || 0) > 0;\nconst hasMissingCoverage = Object.values(extractedRules.coverage_summary || {}).some(\n  c => c.extracted === false\n);\n\nreturn {\n  json: {\n    ...previousData,\n    extracted_rules: extractedRules,\n    pinecone_records: pineconeRecords,\n    rule_count: extractedRules.rules.length,\n    ambiguity_count: extractedRules.ambiguities?.length || 0,\n    coverage_summary: extractedRules.coverage_summary,\n    retention_expiry: retentionExpiry.toISOString(),\n    requires_human_review: hasLowConfidence || hasAmbiguities || hasMissingCoverage,\n    review_reasons: [\n      hasLowConfidence ? 'Low confidence rules detected' : null,\n      hasAmbiguities ? 'Ambiguities require clarification' : null,\n      hasMissingCoverage ? 'Some categories have no rules extracted' : null\n    ].filter(Boolean)\n  }\n};"
      },
      "id": "parse-rules",
      "name": "Parse & Prepare Rules v2.1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1540, 300],
      "notes": "v2.1: Maneja cross_border_flow, subcategory, practical_example, coverage_summary"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "requires-review",
              "leftValue": "={{ $json.requires_human_review }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-review-needed",
      "name": "Requires Human Review?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1760, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO client_configurations (client_id, version, retention_expiry, rule_count, status, pinecone_namespace, metadata)\nVALUES (\n  '{{ $json.client_id }}',\n  '{{ $json.extracted_rules.extraction_metadata.configuration_version }}',\n  '{{ $json.retention_expiry }}'::timestamptz,\n  {{ $json.rule_count }},\n  'pending_review',\n  '{{ $json.namespace }}',\n  '{{ JSON.stringify({ ambiguities: $json.extracted_rules.ambiguities, coverage: $json.coverage_summary, review_reasons: $json.review_reasons }) }}'::jsonb\n)\nON CONFLICT (client_id, version) DO UPDATE SET\n  rule_count = EXCLUDED.rule_count,\n  status = 'pending_review',\n  metadata = EXCLUDED.metadata;",
        "options": {}
      },
      "id": "save-pending-review",
      "name": "Save as Pending Review",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1980, 200],
      "credentials": {
        "postgres": {
          "id": "POSTGRES_CREDENTIAL_ID",
          "name": "Ops1 PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/embeddings",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"text-embedding-3-small\",\n  \"input\": {{ JSON.stringify($json.pinecone_records.map(r => r.metadata.embedding_text)) }}\n}",
        "options": {
          "timeout": 30000
        }
      },
      "id": "generate-embeddings",
      "name": "Generate Embeddings",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1980, 400],
      "credentials": {
        "httpHeaderAuth": {
          "id": "OPENAI_CREDENTIAL_ID",
          "name": "OpenAI API Key"
        }
      },
      "notes": "v2.1: Usa embedding_text optimizado (category + subcategory + rule + conditions)"
    },
    {
      "parameters": {
        "jsCode": "// Combine rules with their embeddings\nconst embedResponse = $input.first().json;\nconst rulesData = $('Parse & Prepare Rules v2.1').first().json;\n\nconst embeddings = embedResponse.data;\n\n// Match embeddings to records\nconst recordsWithEmbeddings = rulesData.pinecone_records.map((record, index) => ({\n  ...record,\n  values: embeddings[index].embedding\n}));\n\nreturn {\n  json: {\n    ...rulesData,\n    pinecone_records: recordsWithEmbeddings\n  }\n};"
      },
      "id": "combine-embeddings",
      "name": "Combine Embeddings with Rules",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2200, 400]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://{{ $env.PINECONE_HOST }}/vectors/upsert",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Api-Key",
              "value": "={{ $env.PINECONE_API_KEY }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"vectors\": {{ JSON.stringify($json.pinecone_records) }},\n  \"namespace\": \"{{ $json.namespace }}\"\n}",
        "options": {
          "timeout": 30000
        }
      },
      "id": "upsert-pinecone",
      "name": "Upsert to Pinecone",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2420, 400],
      "credentials": {
        "httpHeaderAuth": {
          "id": "PINECONE_CREDENTIAL_ID",
          "name": "Pinecone API Key"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO client_configurations (client_id, version, retention_expiry, rule_count, status, pinecone_namespace, metadata)\nVALUES (\n  '{{ $('Parse & Prepare Rules v2.1').item.json.client_id }}',\n  '{{ $('Parse & Prepare Rules v2.1').item.json.extracted_rules.extraction_metadata.configuration_version }}',\n  '{{ $('Parse & Prepare Rules v2.1').item.json.retention_expiry }}'::timestamptz,\n  {{ $('Parse & Prepare Rules v2.1').item.json.rule_count }},\n  'active',\n  '{{ $('Parse & Prepare Rules v2.1').item.json.namespace }}',\n  '{{ JSON.stringify($('Parse & Prepare Rules v2.1').item.json.coverage_summary) }}'::jsonb\n)\nON CONFLICT (client_id, version) DO UPDATE SET\n  rule_count = EXCLUDED.rule_count,\n  status = 'active',\n  metadata = EXCLUDED.metadata;",
        "options": {}
      },
      "id": "save-active-config",
      "name": "Save Active Configuration",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [2640, 400],
      "credentials": {
        "postgres": {
          "id": "POSTGRES_CREDENTIAL_ID",
          "name": "Ops1 PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO access_log (client_id, task_id, action_type, namespace_accessed, records_affected, status, metadata)\nVALUES (\n  '{{ $('Parse & Prepare Rules v2.1').item.json.client_id }}',\n  '{{ $('Parse & Prepare Rules v2.1').item.json.task_id }}',\n  'configuration',\n  '{{ $('Parse & Prepare Rules v2.1').item.json.namespace }}',\n  {{ $('Parse & Prepare Rules v2.1').item.json.rule_count }},\n  'success',\n  '{{ JSON.stringify({ stage: \"complete\", version: \"2.1\", pdf_reduction_percent: $('PDF Legal Cleaner Pro v2.1').item.json.reduction_percent || 0, coverage: $('Parse & Prepare Rules v2.1').item.json.coverage_summary }) }}'::jsonb\n);",
        "options": {}
      },
      "id": "log-complete",
      "name": "Log Access Complete",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [2860, 400],
      "credentials": {
        "postgres": {
          "id": "POSTGRES_CREDENTIAL_ID",
          "name": "Ops1 PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"success\": true,\n  \"client_id\": \"{{ $('Parse & Prepare Rules v2.1').item.json.client_id }}\",\n  \"task_id\": \"{{ $('Parse & Prepare Rules v2.1').item.json.task_id }}\",\n  \"configuration\": {\n    \"version\": \"{{ $('Parse & Prepare Rules v2.1').item.json.extracted_rules.extraction_metadata.configuration_version }}\",\n    \"rules_extracted\": {{ $('Parse & Prepare Rules v2.1').item.json.rule_count }},\n    \"namespace\": \"{{ $('Parse & Prepare Rules v2.1').item.json.namespace }}\",\n    \"status\": \"active\",\n    \"retention_expiry\": \"{{ $('Parse & Prepare Rules v2.1').item.json.retention_expiry }}\"\n  },\n  \"coverage_summary\": {{ JSON.stringify($('Parse & Prepare Rules v2.1').item.json.coverage_summary) }},\n  \"preprocessing\": {\n    \"pdf_cleaning_applied\": true,\n    \"original_length\": {{ $('PDF Legal Cleaner Pro v2.1').item.json.original_length || 0 }},\n    \"cleaned_length\": {{ $('PDF Legal Cleaner Pro v2.1').item.json.cleaned_length || 0 }},\n    \"reduction_percent\": {{ $('PDF Legal Cleaner Pro v2.1').item.json.reduction_percent || 0 }}\n  },\n  \"legal_notice\": \"Configuration v2.1 generated by Ops-1. Optimized for cross-border CA-US-MX operations. Rules extracted from provided documentation - review by qualified tax professional recommended.\"\n}",
        "options": {}
      },
      "id": "respond-success",
      "name": "Respond - Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [3080, 400]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"success\": true,\n  \"client_id\": \"{{ $('Parse & Prepare Rules v2.1').item.json.client_id }}\",\n  \"task_id\": \"{{ $('Parse & Prepare Rules v2.1').item.json.task_id }}\",\n  \"configuration\": {\n    \"version\": \"{{ $('Parse & Prepare Rules v2.1').item.json.extracted_rules.extraction_metadata.configuration_version }}\",\n    \"rules_extracted\": {{ $('Parse & Prepare Rules v2.1').item.json.rule_count }},\n    \"status\": \"pending_review\",\n    \"review_reasons\": {{ JSON.stringify($('Parse & Prepare Rules v2.1').item.json.review_reasons) }}\n  },\n  \"coverage_summary\": {{ JSON.stringify($('Parse & Prepare Rules v2.1').item.json.coverage_summary) }},\n  \"ambiguities\": {{ JSON.stringify($('Parse & Prepare Rules v2.1').item.json.extracted_rules.ambiguities) }},\n  \"legal_notice\": \"This configuration requires human review before activation. Please review flagged ambiguities and confirm rules with qualified tax professional.\"\n}",
        "options": {}
      },
      "id": "respond-pending-review",
      "name": "Respond - Pending Review",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [2200, 200]
    }
  ],
  "connections": {
    "Webhook - Configuration Request": {
      "main": [
        [
          {
            "node": "Validate Client ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Client ID": {
      "main": [
        [
          {
            "node": "Log Access Start",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log Access Start": {
      "main": [
        [
          {
            "node": "PDF Legal Cleaner Pro v2.1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PDF Legal Cleaner Pro v2.1": {
      "main": [
        [
          {
            "node": "PII Sanitization (Claude)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PII Sanitization (Claude)": {
      "main": [
        [
          {
            "node": "Parse Sanitized Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Sanitized Content": {
      "main": [
        [
          {
            "node": "Rule Extraction (Claude) v2.1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Rule Extraction (Claude) v2.1": {
      "main": [
        [
          {
            "node": "Parse & Prepare Rules v2.1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse & Prepare Rules v2.1": {
      "main": [
        [
          {
            "node": "Requires Human Review?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Requires Human Review?": {
      "main": [
        [
          {
            "node": "Save as Pending Review",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Generate Embeddings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save as Pending Review": {
      "main": [
        [
          {
            "node": "Respond - Pending Review",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Embeddings": {
      "main": [
        [
          {
            "node": "Combine Embeddings with Rules",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine Embeddings with Rules": {
      "main": [
        [
          {
            "node": "Upsert to Pinecone",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upsert to Pinecone": {
      "main": [
        [
          {
            "node": "Save Active Configuration",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Active Configuration": {
      "main": [
        [
          {
            "node": "Log Access Complete",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log Access Complete": {
      "main": [
        [
          {
            "node": "Respond - Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "name": "Ops-1",
      "createdAt": "2025-01-21T00:00:00.000Z",
      "updatedAt": "2025-01-22T00:00:00.000Z"
    },
    {
      "name": "Configuration",
      "createdAt": "2025-01-21T00:00:00.000Z",
      "updatedAt": "2025-01-22T00:00:00.000Z"
    },
    {
      "name": "v2.1",
      "createdAt": "2025-01-22T00:00:00.000Z",
      "updatedAt": "2025-01-22T00:00:00.000Z"
    },
    {
      "name": "Cross-Border",
      "createdAt": "2025-01-22T00:00:00.000Z",
      "updatedAt": "2025-01-22T00:00:00.000Z"
    }
  ],
  "triggerCount": 1,
  "updatedAt": "2025-01-22T00:00:00.000Z",
  "versionId": "2.1"
}

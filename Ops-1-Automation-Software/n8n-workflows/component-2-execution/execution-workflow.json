{
  "name": "Ops-1 Component 2 - Execution Engine",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "ops1/execute",
        "responseMode": "responseNode",
        "options": {
          "rawBody": true
        }
      },
      "id": "webhook-execute",
      "name": "Webhook - Execute Task",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [0, 400],
      "webhookId": "ops1-execute"
    },
    {
      "parameters": {
        "jsCode": "// Validate input and extract task details\nconst input = $input.first().json;\n\n// Required fields validation\nconst requiredFields = ['client_id', 'task_description', 'mode'];\nfor (const field of requiredFields) {\n  if (!input[field]) {\n    throw new Error(`VALIDATION_ERROR: ${field} is required`);\n  }\n}\n\n// Validate mode\nif (!['excel', 'sql'].includes(input.mode)) {\n  throw new Error('VALIDATION_ERROR: mode must be \"excel\" or \"sql\"');\n}\n\n// Validate client_id format\nconst clientIdPattern = /^[A-Za-z0-9_-]+$/;\nif (!clientIdPattern.test(input.client_id)) {\n  throw new Error('VALIDATION_ERROR: client_id contains invalid characters');\n}\n\n// Generate task ID\nconst taskId = `TASK_${input.client_id}_${Date.now()}`;\n\nreturn {\n  json: {\n    client_id: input.client_id,\n    task_id: taskId,\n    task_description: input.task_description,\n    mode: input.mode,\n    data: input.data || null,\n    schema_whitelist: input.schema_whitelist || null,\n    namespace: `${input.client_id}_RULES`,\n    start_time: Date.now()\n  }\n};"
      },
      "id": "validate-input",
      "name": "Validate Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [220, 400]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT client_id, license_status FROM clients WHERE client_id = '{{ $json.client_id }}' AND license_status = 'active';",
        "options": {}
      },
      "id": "check-license",
      "name": "Check Client License",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [440, 400],
      "credentials": {
        "postgres": {
          "id": "POSTGRES_CREDENTIAL_ID",
          "name": "Ops1 PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "license-valid",
              "leftValue": "={{ $json.length }}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "license-valid",
      "name": "License Valid?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [660, 400]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"success\": false,\n  \"error\": \"LICENSE_ERROR\",\n  \"message\": \"Client license is not active or client does not exist\",\n  \"client_id\": \"{{ $('Validate Input').item.json.client_id }}\"\n}",
        "options": {
          "responseCode": 403
        }
      },
      "id": "respond-license-error",
      "name": "Respond - License Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [880, 280]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO access_log (client_id, task_id, action_type, namespace_accessed, status, metadata)\nVALUES (\n  '{{ $('Validate Input').item.json.client_id }}',\n  '{{ $('Validate Input').item.json.task_id }}',\n  'execution_start',\n  '{{ $('Validate Input').item.json.namespace }}',\n  'success',\n  '{\"mode\": \"{{ $('Validate Input').item.json.mode }}\"}'::jsonb\n)\nRETURNING log_id;",
        "options": {}
      },
      "id": "log-execution-start",
      "name": "Log Execution Start",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [880, 520],
      "credentials": {
        "postgres": {
          "id": "POSTGRES_CREDENTIAL_ID",
          "name": "Ops1 PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/embeddings",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"text-embedding-3-small\",\n  \"input\": \"{{ $('Validate Input').item.json.task_description }}\"\n}",
        "options": {}
      },
      "id": "embed-task",
      "name": "Embed Task Description",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1100, 520],
      "credentials": {
        "httpHeaderAuth": {
          "id": "OPENAI_CREDENTIAL_ID",
          "name": "OpenAI API Key"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://{{ $env.PINECONE_HOST }}/query",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"namespace\": \"{{ $('Validate Input').item.json.namespace }}\",\n  \"vector\": {{ JSON.stringify($json.data[0].embedding) }},\n  \"topK\": 10,\n  \"includeMetadata\": true\n}",
        "options": {}
      },
      "id": "query-pinecone",
      "name": "Retrieve Client Rules",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1320, 520],
      "credentials": {
        "httpHeaderAuth": {
          "id": "PINECONE_CREDENTIAL_ID",
          "name": "Pinecone API Key"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse Pinecone results and prepare rules context\nconst pineconeResponse = $input.first().json;\nconst taskData = $('Validate Input').first().json;\n\nconst clientRules = pineconeResponse.matches\n  .filter(match => match.score > 0.5)  // Only use relevant rules\n  .map(match => ({\n    rule_id: match.metadata.rule_id,\n    category: match.metadata.category,\n    rule_text: match.metadata.rule_text,\n    confidence: match.metadata.confidence,\n    relevance_score: match.score\n  }));\n\n// Format rules as context for AI\nconst rulesContext = clientRules.length > 0\n  ? clientRules.map(r => `[${r.rule_id}] (${r.category}): ${r.rule_text}`).join('\\n')\n  : 'No specific client rules found. Use standard best practices.';\n\nreturn {\n  json: {\n    ...taskData,\n    client_rules: clientRules,\n    rules_context: rulesContext,\n    rules_count: clientRules.length\n  }\n};"
      },
      "id": "parse-rules",
      "name": "Parse Retrieved Rules",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1540, 520]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "mode-check",
              "leftValue": "={{ $json.mode }}",
              "rightValue": "excel",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "mode-branch",
      "name": "Excel or SQL Mode?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1760, 520]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.anthropic.com/v1/messages",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "anthropic-version",
              "value": "2023-06-01"
            },
            {
              "name": "content-type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"claude-3-5-haiku-latest\",\n  \"max_tokens\": 4096,\n  \"system\": \"You are the Ops-1 Excel Processing Module. You generate Python code using Pandas to perform data transformations on spreadsheet data.\\n\\nINPUTS PROVIDED:\\n1. Task Description: What the client wants done\\n2. Client Rule Set: Specific formatting and handling rules for this client\\n3. Data Schema: Column names and sample data\\n\\nYOUR FUNCTION:\\nGenerate Python code that accomplishes the task while respecting ALL client rules.\\n\\nSTRICT CONSTRAINTS:\\n1. Use only: pandas, numpy, openpyxl, csv (standard libraries)\\n2. Never use: os, subprocess, requests, or any network/filesystem operations\\n3. Never execute arbitrary code - only data transformations\\n4. Input variable is always: `df` (pandas DataFrame)\\n5. Output must be assigned to: `result_df` (pandas DataFrame)\\n\\nCODE STRUCTURE:\\n```python\\nimport pandas as pd\\nimport numpy as np\\n\\n# Input: df (provided)\\n\\n# [Your transformation code here]\\n\\nresult_df = [final transformed dataframe]\\n```\\n\\nDOCUMENTATION REQUIREMENT:\\nAdd a comment before each operation citing which Client Rule it follows:\\n```python\\n# Applying Rule R003: Format dates as DD/MM/YYYY\\ndf['date_column'] = pd.to_datetime(df['date_column']).dt.strftime('%d/%m/%Y')\\n```\\n\\nIf no specific rule applies to an operation, note:\\n```python\\n# Standard operation: No specific client rule applies\\n```\\n\\nERROR HANDLING:\\n- If the task is impossible with the given data, return code that raises a descriptive ValueError\\n- Never silently fail or return partial results\",\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"TASK DESCRIPTION:\\n{{ $json.task_description }}\\n\\nCLIENT RULES:\\n{{ $json.rules_context }}\\n\\nDATA SCHEMA:\\n{{ JSON.stringify($json.data) }}\"\n    }\n  ]\n}",
        "options": {}
      },
      "id": "excel-execution",
      "name": "Excel Execution (Claude)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1980, 400],
      "credentials": {
        "httpHeaderAuth": {
          "id": "ANTHROPIC_CREDENTIAL_ID",
          "name": "Anthropic API Key"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// SQL Pre-Filter - Security Check\n// This MUST run before any SQL is executed\n\nconst taskData = $('Parse Retrieved Rules').first().json;\n\n// Define dangerous patterns that will block execution\nconst dangerousPatterns = [\n  { pattern: /\\bDROP\\b/i, name: 'DROP' },\n  { pattern: /\\bDELETE\\b/i, name: 'DELETE' },\n  { pattern: /\\bUPDATE\\b/i, name: 'UPDATE' },\n  { pattern: /\\bINSERT\\b/i, name: 'INSERT' },\n  { pattern: /\\bTRUNCATE\\b/i, name: 'TRUNCATE' },\n  { pattern: /\\bALTER\\b/i, name: 'ALTER' },\n  { pattern: /\\bGRANT\\b/i, name: 'GRANT' },\n  { pattern: /\\bREVOKE\\b/i, name: 'REVOKE' },\n  { pattern: /\\bCREATE\\b/i, name: 'CREATE' },\n  { pattern: /\\bREPLACE\\b/i, name: 'REPLACE' },\n  { pattern: /\\bEXEC\\b/i, name: 'EXEC' },\n  { pattern: /\\bEXECUTE\\b/i, name: 'EXECUTE' },\n  { pattern: /--.*\\b(DROP|DELETE|UPDATE|INSERT)\\b/i, name: 'HIDDEN_IN_COMMENT' },\n  { pattern: /\\/\\*.*\\b(DROP|DELETE|UPDATE|INSERT)\\b.*\\*\\//i, name: 'HIDDEN_IN_BLOCK_COMMENT' }\n];\n\n// Pre-check task description for obvious injection attempts\nconst taskDescription = taskData.task_description;\nfor (const { pattern, name } of dangerousPatterns) {\n  if (pattern.test(taskDescription)) {\n    throw new Error(`SECURITY_BLOCK: Prohibited SQL operation '${name}' detected in task description. This has been logged.`);\n  }\n}\n\nreturn {\n  json: {\n    ...taskData,\n    sql_prefilter_passed: true,\n    dangerous_patterns: dangerousPatterns.map(p => p.name)  // For reference in SQL generation\n  }\n};"
      },
      "id": "sql-prefilter",
      "name": "SQL Pre-Filter (Security)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1980, 640]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.anthropic.com/v1/messages",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "anthropic-version",
              "value": "2023-06-01"
            },
            {
              "name": "content-type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"claude-3-5-haiku-latest\",\n  \"max_tokens\": 4096,\n  \"system\": \"You are the Ops-1 SQL Query Module. You generate READ-ONLY SQL queries to retrieve data from client databases.\\n\\nINPUTS PROVIDED:\\n1. Task Description: What data the client needs\\n2. Client Rule Set: Specific rules about data access and formatting\\n3. Permitted Schema: Tables and columns this client has authorized for access\\n\\nYOUR FUNCTION:\\nGenerate a SQL SELECT query that retrieves the requested data.\\n\\nABSOLUTE PROHIBITIONS (will cause immediate rejection):\\n- DROP, DELETE, UPDATE, INSERT, TRUNCATE, ALTER, GRANT, REVOKE\\n- CREATE, REPLACE, EXEC, EXECUTE\\n- Stored procedure calls\\n- Comments containing the above keywords\\n- UNION with subqueries to unauthorized tables\\n- Any attempt to access tables/columns NOT in Permitted Schema\\n\\nPERMITTED OPERATIONS ONLY:\\n- SELECT\\n- FROM (authorized tables only)\\n- WHERE, AND, OR, NOT, IN, BETWEEN, LIKE\\n- JOIN (authorized tables only)\\n- GROUP BY, HAVING\\n- ORDER BY\\n- LIMIT/TOP\\n- COUNT, SUM, AVG, MIN, MAX, DISTINCT\\n- CASE WHEN (for conditional logic)\\n- Standard date/string functions\\n\\nOUTPUT FORMAT:\\n```sql\\n-- Task: [Brief description]\\n-- Rules Applied: [List rule IDs that influenced this query]\\n-- Tables Accessed: [List tables used]\\n\\n[YOUR SELECT QUERY HERE]\\n```\\n\\nSCHEMA VALIDATION:\\nBefore writing the query, verify ALL tables and columns exist in the Permitted Schema.\\nIf the task requires data outside the Permitted Schema, respond:\\n\\\"BLOCKED: This task requires access to [table/column] which is not in the authorized schema for this client.\\\"\",\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"TASK DESCRIPTION:\\n{{ $json.task_description }}\\n\\nCLIENT RULES:\\n{{ $json.rules_context }}\\n\\nPERMITTED SCHEMA:\\n{{ JSON.stringify($json.schema_whitelist) }}\"\n    }\n  ]\n}",
        "options": {}
      },
      "id": "sql-execution",
      "name": "SQL Execution (Claude)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2200, 640],
      "credentials": {
        "httpHeaderAuth": {
          "id": "ANTHROPIC_CREDENTIAL_ID",
          "name": "Anthropic API Key"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse Excel execution response\nconst response = $input.first().json;\nconst taskData = $('Parse Retrieved Rules').first().json;\n\nif (!response.content || !response.content[0] || !response.content[0].text) {\n  throw new Error('AI_ERROR: Invalid response from Excel execution');\n}\n\nconst aiResponse = response.content[0].text;\n\n// Extract Python code from response\nlet pythonCode = aiResponse;\nconst codeMatch = aiResponse.match(/```python\\s*([\\s\\S]*?)```/);\nif (codeMatch) {\n  pythonCode = codeMatch[1].trim();\n}\n\n// Security check for prohibited imports\nconst prohibitedPatterns = [\n  /import\\s+os/,\n  /import\\s+subprocess/,\n  /import\\s+requests/,\n  /from\\s+os\\s+import/,\n  /from\\s+subprocess\\s+import/,\n  /open\\s*\\(/,\n  /exec\\s*\\(/,\n  /eval\\s*\\(/,\n  /__import__/\n];\n\nfor (const pattern of prohibitedPatterns) {\n  if (pattern.test(pythonCode)) {\n    throw new Error('SECURITY_BLOCK: Prohibited code pattern detected');\n  }\n}\n\nconst endTime = Date.now();\n\nreturn {\n  json: {\n    ...taskData,\n    mode: 'excel',\n    generated_code: pythonCode,\n    rules_applied: taskData.client_rules.map(r => r.rule_id),\n    execution_duration_ms: endTime - taskData.start_time\n  }\n};"
      },
      "id": "parse-excel-result",
      "name": "Parse Excel Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2200, 400]
    },
    {
      "parameters": {
        "jsCode": "// Parse SQL execution response and validate\nconst response = $input.first().json;\nconst taskData = $('SQL Pre-Filter (Security)').first().json;\n\nif (!response.content || !response.content[0] || !response.content[0].text) {\n  throw new Error('AI_ERROR: Invalid response from SQL execution');\n}\n\nconst aiResponse = response.content[0].text;\n\n// Check if AI blocked the request\nif (aiResponse.includes('BLOCKED:')) {\n  return {\n    json: {\n      ...taskData,\n      mode: 'sql',\n      blocked: true,\n      block_reason: aiResponse,\n      execution_duration_ms: Date.now() - taskData.start_time\n    }\n  };\n}\n\n// Extract SQL from response\nlet sqlQuery = aiResponse;\nconst sqlMatch = aiResponse.match(/```sql\\s*([\\s\\S]*?)```/);\nif (sqlMatch) {\n  sqlQuery = sqlMatch[1].trim();\n}\n\n// Final security validation - regex check for dangerous operations\nconst dangerousPatterns = [\n  /\\bDROP\\b/i,\n  /\\bDELETE\\b/i,\n  /\\bUPDATE\\b/i,\n  /\\bINSERT\\b/i,\n  /\\bTRUNCATE\\b/i,\n  /\\bALTER\\b/i,\n  /\\bGRANT\\b/i,\n  /\\bREVOKE\\b/i,\n  /\\bCREATE\\b/i,\n  /\\bREPLACE\\b/i,\n  /\\bEXEC\\b/i,\n  /\\bEXECUTE\\b/i\n];\n\nfor (const pattern of dangerousPatterns) {\n  if (pattern.test(sqlQuery)) {\n    throw new Error(`SECURITY_BLOCK: Prohibited SQL operation detected in generated query. Pattern: ${pattern}`);\n  }\n}\n\nconst endTime = Date.now();\n\nreturn {\n  json: {\n    ...taskData,\n    mode: 'sql',\n    blocked: false,\n    generated_sql: sqlQuery,\n    rules_applied: taskData.client_rules.map(r => r.rule_id),\n    execution_duration_ms: endTime - taskData.start_time\n  }\n};"
      },
      "id": "parse-sql-result",
      "name": "Parse SQL Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2420, 640]
    },
    {
      "parameters": {
        "jsCode": "// Merge results from both branches\nconst excelResult = $('Parse Excel Result').first();\nconst sqlResult = $('Parse SQL Result').first();\n\n// Return whichever branch executed\nconst result = excelResult?.json?.mode === 'excel' ? excelResult.json : sqlResult?.json;\n\nif (!result) {\n  throw new Error('EXECUTION_ERROR: No result from either branch');\n}\n\nreturn { json: result };"
      },
      "id": "merge-results",
      "name": "Merge Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2640, 520]
    },
    {
      "parameters": {
        "jsCode": "// Prepare audit package for Component 3\nconst result = $input.first().json;\n\nconst auditPackage = {\n  task_id: result.task_id,\n  client_id: result.client_id,\n  mode: result.mode,\n  task_description: result.task_description,\n  \n  execution: {\n    generated_output: result.mode === 'excel' ? result.generated_code : result.generated_sql,\n    blocked: result.blocked || false,\n    block_reason: result.block_reason || null,\n    execution_duration_ms: result.execution_duration_ms\n  },\n  \n  compliance: {\n    rules_retrieved: result.rules_count,\n    rules_applied: result.rules_applied,\n    client_rules: result.client_rules\n  },\n  \n  metadata: {\n    namespace: result.namespace,\n    timestamp: new Date().toISOString()\n  }\n};\n\nreturn { json: auditPackage };"
      },
      "id": "prepare-audit",
      "name": "Prepare Audit Package",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2860, 520]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.N8N_WEBHOOK_BASE_URL }}/webhook/ops1/compliance",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json) }}",
        "options": {}
      },
      "id": "send-to-compliance",
      "name": "Send to Compliance Module",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [3080, 520]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json) }}",
        "options": {}
      },
      "id": "respond-final",
      "name": "Respond - Final Result",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [3300, 520]
    }
  ],
  "connections": {
    "Webhook - Execute Task": {
      "main": [
        [
          {
            "node": "Validate Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Input": {
      "main": [
        [
          {
            "node": "Check Client License",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Client License": {
      "main": [
        [
          {
            "node": "License Valid?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "License Valid?": {
      "main": [
        [
          {
            "node": "Respond - License Error",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Log Execution Start",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log Execution Start": {
      "main": [
        [
          {
            "node": "Embed Task Description",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Embed Task Description": {
      "main": [
        [
          {
            "node": "Retrieve Client Rules",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Retrieve Client Rules": {
      "main": [
        [
          {
            "node": "Parse Retrieved Rules",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Retrieved Rules": {
      "main": [
        [
          {
            "node": "Excel or SQL Mode?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Excel or SQL Mode?": {
      "main": [
        [
          {
            "node": "Excel Execution (Claude)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "SQL Pre-Filter (Security)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Excel Execution (Claude)": {
      "main": [
        [
          {
            "node": "Parse Excel Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SQL Pre-Filter (Security)": {
      "main": [
        [
          {
            "node": "SQL Execution (Claude)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SQL Execution (Claude)": {
      "main": [
        [
          {
            "node": "Parse SQL Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Excel Result": {
      "main": [
        [
          {
            "node": "Merge Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse SQL Result": {
      "main": [
        [
          {
            "node": "Merge Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Results": {
      "main": [
        [
          {
            "node": "Prepare Audit Package",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Audit Package": {
      "main": [
        [
          {
            "node": "Send to Compliance Module",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send to Compliance Module": {
      "main": [
        [
          {
            "node": "Respond - Final Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "name": "Ops-1",
      "createdAt": "2025-01-21T00:00:00.000Z",
      "updatedAt": "2025-01-21T00:00:00.000Z"
    },
    {
      "name": "Execution",
      "createdAt": "2025-01-21T00:00:00.000Z",
      "updatedAt": "2025-01-21T00:00:00.000Z"
    }
  ],
  "triggerCount": 1,
  "updatedAt": "2025-01-21T00:00:00.000Z",
  "versionId": "1"
}
